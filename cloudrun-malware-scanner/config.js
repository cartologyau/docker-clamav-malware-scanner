/*
* Copyright 2022 Google LLC

* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at

*     https://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

const {Storage} = require('@google-cloud/storage');
const {logger} = require('./logger.js');
const pkgJson = require('./package.json');
const {readFileSync} = require('node:fs');
/**
 * @typedef {{
 *  unscanned: string,
 *  clean: string,
 *  quarantined: string,
 * }} BucketDefs
 */

/** @type {Array<keyof BucketDefs>} */
const BUCKET_TYPES = ['unscanned', 'clean', 'quarantined'];

/**
 * Configuration object.
 *
 * Values are read from the JSON configuration file.
 * See {@link readAndVerifyConfig}.
 *
 * @typedef {{
 *    buckets: Array<BucketDefs>,
 *    ClamCvdMirrorBucket: string,
 *    fileExclusionPatterns?: Array<string | Array<string>>,
 *    fileExclusionRegexps: Array<RegExp>,
 *    ignoreZeroLengthFiles: boolean,
 *    comments?: string
 *  }} Config
 */

const storage = new Storage({
  userAgent: `cloud-solutions/${pkgJson.name}-usage-v${pkgJson.version}`,
});

/**
 * Read configuration from JSON configuration file, verify
 * and return a Config object
 *
 * @async
 * @param {string} configFile
 * @return {Promise<Config>}
 */
async function readAndVerifyConfig(configFile) {
  logger.info(`Using configuration file: ${configFile}`);
  let configText;
  try {
    configText = readFileSync(configFile, {encoding: 'utf-8'});
  } catch (e) {
    const err = /** @type {Error} */ (e);
    logger.fatal(
      err,
      `Unable to read JSON file from ${configFile}: ${err.message}`,
    );
    throw err;
  }
  try {
    return verifyConfig(configText);
  } catch (e) {
    const err = /** @type {Error} */ (e);
    logger.fatal(
      err,
      `Failed parsing config file: ${configFile}: ${err.message}`,
    );
    throw err;
  }
}

/**
 * Read configuration from JSON configuration file, verify
 * and return a Config object
 *
 * @async
 * @param {string} configText
 * @return {Promise<Config>}
 */
async function verifyConfig(configText) {
  /** @type {Config} */
  let config;

  try {
    config = JSON.parse(configText);
  } catch (e) {
    const err = /** @type {Error} */ (e);
    throw new Error(`Failed to parse configuration as JSON: ${err.message}`);
  }

  delete config.comments;

  if (config.buckets.length === 0) {
    logger.fatal(`No buckets configured for scanning`);
    throw new Error('No buckets configured');
  }

  logger.info('BUCKET_CONFIG: ' + JSON.stringify(config, null, 2));

  // Check buckets are specified and exist.
  let success = true;
  for (let x = 0; x < config.buckets.length; x++) {
    const bucketDefs = config.buckets[x];
    for (const bucketType of BUCKET_TYPES) {
      if (
        !(await checkBucketExists(
          bucketDefs[bucketType],
          `config.buckets[${x}].${bucketType}`,
        ))
      ) {
        success = false;
      }
    }
    if (
      bucketDefs.unscanned === bucketDefs.clean ||
      bucketDefs.unscanned === bucketDefs.quarantined ||
      bucketDefs.clean === bucketDefs.quarantined
    ) {
      logger.fatal(`Config Error: buckets[${x}]: bucket names are not unique`);
      // success = false;
    }
  }
  if (
    !(await checkBucketExists(
      config.ClamCvdMirrorBucket,
      'ClamCvdMirrorBucket',
    ))
  ) {
    success = false;
  }

  // Validate ignoreZeroLengthFiles
  if (config.ignoreZeroLengthFiles == null) {
    config.ignoreZeroLengthFiles = false;
  } else if (typeof config.ignoreZeroLengthFiles !== 'boolean') {
    logger.fatal(
      `Config Error: ignoreZeroLengthFiles must be true or false: ${JSON.stringify(config.ignoreZeroLengthFiles)}`,
    );
    success = false;
  }

  // Validate fileExclusionPatterns
  config.fileExclusionRegexps = [];
  if (config.fileExclusionPatterns == null) {
    // not specified.
    config.fileExclusionPatterns = [];
  } else {
    if (!(config.fileExclusionPatterns instanceof Array)) {
      logger.fatal(
        `Config Error: fileExclusionPatterns must be an array of Strings`,
      );
      success = false;
    } else {
      // config.fileExclusionPatterns is an array, check each value and
      // convert to a regexp in fileExclusionRegexps[]
      for (const i in config.fileExclusionPatterns) {
        /** @type {string|undefined} */
        let pattern;
        /** @type {string|undefined} */
        let flags;

        // Each element can either be a simple pattern:
        //   "^.*\\.tmp$"
        // or an array with pattern and flags, eg for case-insensive matching:
        //   [ "^.*\\tmp$", "i" ]

        if (typeof config.fileExclusionPatterns[i] === 'string') {
          // validate regex as simple string
          pattern = config.fileExclusionPatterns[i];
        } else if (
          config.fileExclusionPatterns[i] instanceof Array &&
          config.fileExclusionPatterns[i].length <= 2 &&
          config.fileExclusionPatterns[i].length >= 1 &&
          typeof config.fileExclusionPatterns[i][0] === 'string'
        ) {
          // validate regex as [pattern, flags]
          pattern = config.fileExclusionPatterns[i][0];
          flags = config.fileExclusionPatterns[i][1];
        } else {
          pattern = undefined;
        }

        if (pattern == null) {
          logger.fatal(
            `Config Error: fileExclusionPatterns[${i}] must be either a string or an array of 2 strings: ${JSON.stringify(config.fileExclusionPatterns[i])}`,
          );
          success = false;
        } else {
          try {
            config.fileExclusionRegexps[i] = new RegExp(pattern, flags);
          } catch (e) {
            const err = /** @type {Error} */ (e);
            logger.fatal(
              err,
              `Config Error: fileExclusionPatterns[${i}]:  Regexp compile failed for ${JSON.stringify(config.fileExclusionPatterns[i])}: ${err.message}`,
            );
            success = false;
          }
        }
      }
    }
  }

  if (!success) {
    throw new Error('Invalid configuration');
  }
  return config;
}

/**
 * Check that given bucket exists. Returns true on success
 *
 * @param {string} bucketName
 * @param {string} configName
 * @return {Promise<boolean>}
 */
async function checkBucketExists(bucketName, configName) {
  if (!bucketName) {
    logger.fatal(`Config Error: no "${configName}" bucket defined`);
    return false;
  }
  // Check for bucket existence by listing files in bucket, will throw
  // an exception if the bucket is not readable.
  // This is used in place of Bucket.exists() to avoid the need for
  // Project/viewer permission.
  try {
    await storage
      .bucket(bucketName)
      .getFiles({maxResults: 1, prefix: 'zzz', autoPaginate: false});
    return true;
  } catch (e) {
    logger.fatal(
      `Error in config: cannot view files in "${configName}" : ${bucketName} : ${e}`,
    );
    logger.debug({err: e});
    return false;
  }
}

module.exports = {
  readAndVerifyConfig,
  TEST_ONLY: {
    storage,
  },
};
