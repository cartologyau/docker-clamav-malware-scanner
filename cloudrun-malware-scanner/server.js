/*
* Copyright 2022 Google LLC

* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at

*     https://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

const process = require('node:process');
// @ts-ignore -- TS7016: Could not find a declaration file
const clamd = require('clamdjs');
const express = require('express');
const {Storage} = require('@google-cloud/storage');
const {GoogleAuth} = require('google-auth-library');
const {logger} = require('./logger.js');
const pkgJson = require('./package.json');
const metrics = require('./metrics.js');
const {Scanner} = require('./scanner.js');
const util = require('node:util');
const execFile = util.promisify(require('node:child_process').execFile);
const {setTimeout} = require('timers/promises');
const {readAndVerifyConfig} = require('./config.js');

/** @typedef {import('./config.js').Config} Config */
/** @typedef {import('./config.js').BucketDefs} BucketDefs */
/** @typedef {import('express').Request} Request */
/** @typedef {import('express').Response} Response */
/** @typedef {import('./scanner.js').StorageObjectData} StorageObjectData */

/** Encapsulates the HTTP server and its methods */
class Server {
  /**
   * @param {Scanner} scanner
   * @param {Config} config
   * @param {number} port
   */
  constructor(scanner, config, port) {
    this.scanner = scanner;
    this.config = config;
    this.port = port;

    this.app = express();
    this.app.use(express.json());
    this.app.get('/', (_, res) => this.versionInfo(res));
    this.app.post('/', (req, res) => this.handlePost(req, res));
    this.app.get('/ready', (_, res) => this.healthCheck(res));
  }

  /**
   * Trivial handler for get requests which returns the clam version.
   *
   * Use:
   * curl -D - -H "Authorization: Bearer $(gcloud auth print-identity-token)"  CLOUD_RUN_APP_URL
   *
   * @param {!Response} res
   */
  async versionInfo(res) {
    res
      .status(200)
      .type('text/plain')
      .send(
        `${pkgJson.name} version ${pkgJson.version}\nUsing Clam AV version: ${await this.scanner.getClamVersion()}\n\n${pkgJson.description}\n\n`,
      );
  }

  /**
   * Health check from cloud run.
   * Verifies that clamd is running.
   *
   * @param {!Response} res
   */
  async healthCheck(res) {
    try {
      await this.scanner.pingClamD();
      res.status(200).json({message: 'Health Check Suceeded'});
    } catch (e) {
      const err = /** @type {Error} */ (e);
      logger.fatal(err, `Health check failed to contact clamd: ${err.message}`);
      res.status(500).json({message: 'Health Check Failed', status: 'error'});
    }
  }

  /**
   * Route that is invoked by Cloud Run when a malware scan is requested
   * for a document uploaded to GCS.
   *
   * @param {!Request} req
   * @param {!Response} res
   */
  async handlePost(req, res) {
    try {
      switch (req.body.kind) {
        case 'storage#object':
          res.json(await this.scanner.handleGcsObject(req.body));
          break;

        case 'schedule#cvd_update':
          res.json(await handleCvdUpdate(this.config));
          break;

        default:
          logger.error(
            {payload: req.body},
            `Error processing request: object kind: ${req.body.kind} is not supported`,
          );
          res.status(400).json({message: 'invalid request', status: 'error'});
          break;
      }
    } catch (e) {
      logger.error(
        {err: e, payload: req.body},
        `Failure when processing request: ${e}`,
      );
      res.status(500).json({message: e, status: 'error'});
    }
  }

  start() {
    this.app.listen(this.port, () => {
      logger.info(
        `${pkgJson.name} version ${pkgJson.version} started on port ${this.port}`,
      );
    });
  }
}

/**
 * Triggers a update check on the CVD Mirror GCS bucket.
 *
 * @param {Config} config
 * @returns {Promise<Object>}
 */
async function handleCvdUpdate(config) {
  try {
    logger.info('Starting CVD Mirror update');
    const result = await execFile('./updateCvdMirror.sh', [
      config.ClamCvdMirrorBucket,
    ]);
    logger.info('CVD Mirror update check complete. output:\n' + result.stdout);
    // look for updated versions in output by looking for
    // "updated (version: " from freshclam output.
    const newVersions = result.stdout
      .split('\n')
      // Look for lines beginning with Downloaded
      .filter((line) => line.indexOf('Downloaded') >= 0);
    for (const version of newVersions) {
      logger.info(`CVD Mirror updated: ${version}`);
    }
    const isUpdated = newVersions.length > 0;
    metrics.writeCvdMirrorUpdated(true, isUpdated);
    return {
      status: 'CvdUpdateComplete',
      updated: isUpdated,
    };
  } catch (err) {
    const e = /** @type {import('node:child_process').ExecFileException} */ (
      err
    );
    logger.error(
      {err: e},
      `Failure when running ./updateCvdMirror.sh: ${e}\nstdout: ${e.stdout}\nstderr: \n${e.stderr}`,
    );
    metrics.writeCvdMirrorUpdated(false, false);
    throw e;
  }
}

/**
 *  Wait up to 5 mins for ClamD to respond
 * @param {Scanner} scanner
 */
async function waitForClamD(scanner) {
  const timeoutMins = 10;
  const endTime = Date.now() + timeoutMins * 60 * 1000;

  logger.info('Waiting for Clamd');
  while (Date.now() < endTime) {
    try {
      const version = await scanner.getClamVersion();
      logger.info(`Clamd started with version ${version}`);
      return;
    } catch (e) {
      logger.warn(`Waiting for clamd to start: ${e}`);
    }
    await setTimeout(10000);
  }
  logger.fatal(`Clamd not started after ${timeoutMins} mins`);
  process.exit(1);
}

/**
 * Perform async setup and start the app.
 *
 * @async
 */
async function run() {
  let projectId = process.env.PROJECT_ID;
  if (!projectId) {
    // Metrics needs project ID, so get it from GoogleAuth
    projectId = await new GoogleAuth().getProjectId();
  }
  await metrics.init(projectId);

  const storage = new Storage({
    userAgent: `cloud-solutions/${pkgJson.name}-usage-v${pkgJson.version}`,
  });

  let configFile;
  if (process.argv.length >= 3) {
    configFile = process.argv[2];
  } else {
    configFile = './config.json';
  }

  const config = await readAndVerifyConfig(configFile, storage);

  const scanner = new Scanner(config, clamd, storage, metrics);

  await waitForClamD(scanner);

  new Server(scanner, config, parseInt(process.env.PORT || '8080')).start();
}

// Start the service, exiting on error.
run().catch((e) => {
  logger.fatal(e);
  logger.fatal('Exiting');
  process.exit(1);
});
