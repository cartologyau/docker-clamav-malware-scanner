/*
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {Scanner, StorageObjectData} from '../scanner';
import * as metrics from '../metrics';
import {Config} from '../config.js';
import {Readable} from 'node:stream';
import * as gcs from '@google-cloud/storage';
import * as ClamdClient from 'clamdjs';

const CONFIG: Config = {
  buckets: [
    {
      unscanned: 'unscannedBucket',
      quarantined: 'quarantinedBucket',
      clean: 'cleanBucket',
    },
  ],
  ClamCvdMirrorBucket: 'csvMirrorBucket',
  fileExclusionRegexps: [],
  ignoreZeroLengthFiles: false,
};

const CLAMD_VERSION_STRING = 'clamd_version_string';
const TEST_FILE_NAME = 'testFileName';

describe('Scanner', () => {
  let clamdClient: jasmine.SpyObj<typeof ClamdClient>;
  let scanStreamFunc: jasmine.Spy<ClamdClient.ScanStreamFunc>;
  let metricsClient: jasmine.SpyObj<typeof metrics>;
  let storageClient: jasmine.SpyObj<gcs.Storage>;
  let mockUnscannedBucket: jasmine.SpyObj<gcs.Bucket>;
  let mockCleanBucket: jasmine.SpyObj<gcs.Bucket>;
  let mockQuarantinedBucket: jasmine.SpyObj<gcs.Bucket>;
  let mockFile: jasmine.SpyObj<gcs.File>;

  let scanner: Scanner;

  beforeEach(() => {
    clamdClient = jasmine.createSpyObj<typeof clamdClient>('ClamdClient', [
      'createScanner',
      'version',
      'ping',
      'isCleanReply',
    ]);
    scanStreamFunc = jasmine.createSpy('scanStreamFunc');
    clamdClient.createScanner.and.returnValue({
      scanStream: scanStreamFunc,
    });
    clamdClient.version.and.resolveTo('clamd_version_string\x00');

    metricsClient = jasmine.createSpyObj<typeof metrics>('MetricsClient', [
      'writeScanFailed',
      'writeScanClean',
      'writeScanIgnored',
      'writeScanInfected',
      'writeCvdMirrorUpdated',
      'init',
    ]);

    storageClient = jasmine.createSpyObj<gcs.Storage>('Storage', ['bucket']);

    mockUnscannedBucket = jasmine.createSpyObj<gcs.Bucket>(
      'unscannedBucket',
      ['file'],
      {
        name: 'unscannedBucket',
      },
    );
    storageClient.bucket
      .withArgs('unscannedBucket')
      .and.returnValue(mockUnscannedBucket);

    mockCleanBucket = jasmine.createSpyObj<gcs.Bucket>(
      'cleanBucket',
      ['file'],
      {
        name: 'cleanBucket',
      },
    );
    storageClient.bucket
      .withArgs('cleanBucket')
      .and.returnValue(mockCleanBucket);

    mockQuarantinedBucket = jasmine.createSpyObj<gcs.Bucket>(
      'quarantinedBucket',
      ['file'],
      {name: 'quarantinedBucket'},
    );
    storageClient.bucket
      .withArgs('quarantinedBucket')
      .and.returnValue(mockQuarantinedBucket);

    mockFile = jasmine.createSpyObj<gcs.File>(
      'testFile',
      ['exists', 'getMetadata', 'createReadStream', 'move'],
      {
        name: TEST_FILE_NAME,
        cloudStorageURI: new URL(
          `gs://${CONFIG.buckets[0].clean}/${TEST_FILE_NAME}`,
        ),
      },
    );
    mockUnscannedBucket.file.withArgs(TEST_FILE_NAME).and.returnValue(mockFile);

    scanner = new Scanner(CONFIG, clamdClient, storageClient, metricsClient);
  });

  it('version returns the version', async () => {
    await expectAsync(scanner.getClamVersion()).toBeResolvedTo(
      CLAMD_VERSION_STRING,
    );
  });

  it('successful pings return', async () => {
    clamdClient.ping.and.resolveTo(true);
    await expectAsync(scanner.pingClamD()).toBeResolved();
  });
  it('unsuccessful pings throw', async () => {
    clamdClient.ping.and.resolveTo(false);
    await expectAsync(scanner.pingClamD()).toBeRejectedWithError(
      /clamd PING failed/,
    );

    clamdClient.ping.and.throwError('exception in Ping');
    await expectAsync(scanner.pingClamD()).toBeRejectedWithError(
      /exception in Ping/,
    );
  });

  describe('handleGcsObject', () => {
    it('validates input', async () => {
      const response = {message: 'ignoring invalid request', status: 'ignored'};

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      let request: any = null;
      await expectAsync(
        scanner.handleGcsObject(request as StorageObjectData),
      ).toBeResolvedTo(response);
      request = {};
      await expectAsync(
        scanner.handleGcsObject(request as StorageObjectData),
      ).toBeResolvedTo(response);
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      request.name = 'filename';
      await expectAsync(
        scanner.handleGcsObject(request as StorageObjectData),
      ).toBeResolvedTo(response);
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      request.bucket = 'size';
      await expectAsync(
        scanner.handleGcsObject(request as StorageObjectData),
      ).toBeResolvedTo(response);
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      request.bucket = 'invalid_bucket';
      await expectAsync(
        scanner.handleGcsObject(request as StorageObjectData),
      ).toBeResolvedTo(response);
      expect(metricsClient.writeScanFailed).toHaveBeenCalledTimes(5);
    });

    it('ignores zero length files when set', async () => {
      const config = structuredClone(CONFIG);
      config.ignoreZeroLengthFiles = true;

      scanner = new Scanner(config, clamdClient, storageClient, metricsClient);

      const request = {name: 'filename', bucket: 'unscannedBucket', size: 0};
      await expectAsync(scanner.handleGcsObject(request)).toBeResolvedTo({
        status: 'ignored',
        message: 'zero_length_file',
      });
      expect(metricsClient.writeScanIgnored).toHaveBeenCalledWith(
        CONFIG.buckets[0].unscanned,
        CONFIG.buckets[0].clean,
        0,
        'ZERO_LENGTH_FILE',
      );
    });

    it('ignores files that are too large', async () => {
      const request = {
        name: 'filename',
        bucket: 'unscannedBucket',
        size: 501000000,
      };
      await expectAsync(scanner.handleGcsObject(request)).toBeResolvedTo({
        status: 'ignored',
        message: 'file_too_large',
      });
      expect(metricsClient.writeScanIgnored).toHaveBeenCalledWith(
        CONFIG.buckets[0].unscanned,
        CONFIG.buckets[0].clean,
        request.size,
        'FILE_TOO_LARGE',
      );
    });

    it('ignores files that match exclusion regex', async () => {
      const config = structuredClone(CONFIG);
      config.fileExclusionRegexps = [/\.tmp$/, /\.multipart\./i];

      scanner = new Scanner(config, clamdClient, storageClient, metricsClient);

      const request = {name: 'file.tmp', bucket: 'unscannedBucket', size: 100};
      await expectAsync(scanner.handleGcsObject(request)).toBeResolvedTo({
        status: 'ignored',
        message: 'exclusion_regexp_match',
      });

      request.name = 'file.multIPART.txt';
      await expectAsync(scanner.handleGcsObject(request)).toBeResolvedTo({
        status: 'ignored',
        message: 'exclusion_regexp_match',
      });

      expect(metricsClient.writeScanIgnored).toHaveBeenCalledWith(
        CONFIG.buckets[0].unscanned,
        CONFIG.buckets[0].clean,
        100,
        'REGEXP_MATCH',
        '/\\.tmp$/',
      );
      expect(metricsClient.writeScanIgnored).toHaveBeenCalledWith(
        CONFIG.buckets[0].unscanned,
        CONFIG.buckets[0].clean,
        100,
        'REGEXP_MATCH',
        '/\\.multipart\\./i',
      );
    });

    it('ignores files who get removed before processing', async () => {
      (mockFile.exists as jasmine.Spy).and.resolveTo([false]);

      const request = {
        name: TEST_FILE_NAME,
        bucket: 'unscannedBucket',
        size: 100,
      };
      await expectAsync(scanner.handleGcsObject(request)).toBeResolvedTo({
        status: 'ignored',
        message: 'file deleted',
      });
      expect(metricsClient.writeScanIgnored).not.toHaveBeenCalled();
      expect(metricsClient.writeScanClean).not.toHaveBeenCalled();
      expect(metricsClient.writeScanFailed).not.toHaveBeenCalled();
    });

    it('ignores files whos size changes before processing', async () => {
      (mockFile.exists as jasmine.Spy).and.resolveTo([true]);
      (mockFile.getMetadata as jasmine.Spy).and.resolveTo([{size: 200}]);

      const request = {
        name: TEST_FILE_NAME,
        bucket: 'unscannedBucket',
        size: 100,
      };
      await expectAsync(scanner.handleGcsObject(request)).toBeResolvedTo({
        status: 'ignored',
        message: 'file_size_mismatch',
      });
      expect(metricsClient.writeScanIgnored).toHaveBeenCalledWith(
        CONFIG.buckets[0].unscanned,
        CONFIG.buckets[0].clean,
        100,
        'FILE_SIZE_MISMATCH',
      );
      expect(metricsClient.writeScanClean).not.toHaveBeenCalled();
      expect(metricsClient.writeScanFailed).not.toHaveBeenCalled();
    });

    describe('scans files', () => {
      const request = {
        name: TEST_FILE_NAME,
        bucket: 'unscannedBucket',
        size: 100,
      };
      let mockReadStream: jasmine.SpyObj<Readable>;

      beforeEach(() => {
        (mockFile.exists as jasmine.Spy).and.resolveTo([true]);
        (mockFile.getMetadata as jasmine.Spy).and.resolveTo([{size: 100}]);

        mockReadStream = jasmine.createSpyObj<Readable>('readableStream', [
          'destroy',
        ]);
        mockFile.createReadStream.and.returnValue(mockReadStream);

        jasmine.clock().install();
        jasmine.clock().mockDate(new Date('2024-01-01T01:00:00Z'));
      });
      afterEach(() => {
        jasmine.clock().uninstall();
      });

      it('throws when getting the stream fails', async () => {
        mockFile.createReadStream.and.throwError('createReadStream Fail');

        await expectAsync(
          scanner.handleGcsObject(request),
        ).toBeRejectedWithError('createReadStream Fail');

        expect(metricsClient.writeScanFailed).toHaveBeenCalledWith(
          CONFIG.buckets[0].unscanned,
        );
      });

      it('throws when scanning the file fails', async () => {
        scanStreamFunc.and.rejectWith('scanfile fail');
        await expectAsync(scanner.handleGcsObject(request)).toBeRejectedWith(
          'scanfile fail',
        );
        expect(metricsClient.writeScanFailed).toHaveBeenCalledWith(
          CONFIG.buckets[0].unscanned,
        );
        // eslint-disable-next-line @typescript-eslint/unbound-method
        expect(mockReadStream.destroy).toHaveBeenCalled();
      });

      it('moves clean files and logs metrics', async () => {
        scanStreamFunc.and.resolveTo('scan success');
        clamdClient.isCleanReply.and.returnValue(true);
        mockFile.move.and.resolveTo();

        await expectAsync(scanner.handleGcsObject(request)).toBeResolvedTo({
          status: 'clean',
          clam_version: CLAMD_VERSION_STRING,
          message: 'scan_success',
        });

        // eslint-disable-next-line @typescript-eslint/unbound-method
        expect(mockReadStream.destroy).toHaveBeenCalled();
        // .toHaveBeenCalledWith does not work due to overloading of func.
        expect(mockFile.move.calls.count()).toBe(1);
        expect(mockFile.move.calls.first().args[0]).toBe(mockCleanBucket);
        expect(metricsClient.writeScanClean).toHaveBeenCalledWith(
          CONFIG.buckets[0].unscanned,
          CONFIG.buckets[0].clean,
          100,
          0,
          CLAMD_VERSION_STRING,
        );
      });

      it('moves infected files and logs metrics', async () => {
        scanStreamFunc.and.resolveTo('scan infected');
        clamdClient.isCleanReply.and.returnValue(false);
        mockFile.move.and.resolveTo();

        await expectAsync(scanner.handleGcsObject(request)).toBeResolvedTo({
          message: 'scan infected',
          status: 'infected',
          clam_version: CLAMD_VERSION_STRING,
        });

        // eslint-disable-next-line @typescript-eslint/unbound-method
        expect(mockReadStream.destroy).toHaveBeenCalled();
        // .toHaveBeenCalledWith does not work due to overloading of func.
        expect(mockFile.move.calls.count()).toBe(1);
        expect(mockFile.move.calls.first().args[0]).toBe(mockQuarantinedBucket);
        expect(metricsClient.writeScanInfected).toHaveBeenCalledWith(
          CONFIG.buckets[0].unscanned,
          CONFIG.buckets[0].quarantined,
          100,
          0,
          CLAMD_VERSION_STRING,
        );
      });
    });
  });
});
