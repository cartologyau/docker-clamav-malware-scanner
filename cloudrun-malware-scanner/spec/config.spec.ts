/*
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const Config = require('../config.js');

/**
 * @typedef {import('@google-cloud/storage').Bucket} Bucket
 * @typedef {import('@google-cloud/storage').Storage} Storage
 */

/** @type {Config.Config} */
const GOOD_CONFIG = {
  buckets: [
    {
      unscanned: 'unscannedBucket',
      quarantined: 'quarantinedBucket',
      clean: 'cleanBucket',
    },
  ],
  ClamCvdMirrorBucket: 'csvMirrorBucket',
  fileExclusionRegexps: [],
  ignoreZeroLengthFiles: false,
};

describe('Config', () => {
  /** @type {jasmine.SpyObj<Storage>} */
  let storageServiceSpy;
  /** @type {jasmine.SpyObj<Bucket>} */
  let existingBucket;

  beforeEach(() => {
    // Mock the 'bucket' method of the storage API object used by Config
    // so that we can fake the behaviour
    storageServiceSpy = /** @type {jasmine.SpyObj<Storage>} */ (
      jasmine.createSpyObj('Storage', ['bucket'])
    );

    // exisiting buckets return an object to getFiles
    existingBucket = jasmine.createSpyObj('existingBucket', ['getFiles']);
    existingBucket.getFiles.and.resolveTo();
    // buckets in GOOD_CONFIG return treat as existingBuckets
    [
      ...Object.values(GOOD_CONFIG.buckets[0]),
      GOOD_CONFIG.ClamCvdMirrorBucket,
    ].forEach((bucket) =>
      storageServiceSpy.bucket.withArgs(bucket).and.returnValue(existingBucket),
    );
  });

  describe('readAndVerifyConfig', () => {
    it('throws when a bad config is passed', async () => {
      await expectAsync(
        Config.readAndVerifyConfig(
          'spec/support/bad-config.notjson',
          storageServiceSpy,
        ),
      ).toBeRejectedWithError(/SyntaxError/);
    });

    it('throws when a missing config file is passed', async () => {
      await expectAsync(
        Config.readAndVerifyConfig(
          'spec/support/no-config-file.json',
          storageServiceSpy,
        ),
      ).toBeRejectedWithError(/no such file or directory/);
    });

    it('returns config when a good config file is passed', async () => {
      const config = await Config.readAndVerifyConfig(
        'spec/support/good-config.json',
        storageServiceSpy,
      );
      expect(config).toEqual(GOOD_CONFIG);
      expect(existingBucket.getFiles).toHaveBeenCalledTimes(4);
    });
  });

  describe('checkBucketExists', () => {
    beforeEach(() => {
      storageServiceSpy.bucket
        .withArgs('existingBucket')
        .and.returnValue(existingBucket);

      // non exisiting buckets calls to getFiles rejects
      const nonExistingBucket = /** @type {jasmine.SpyObj<Bucket>} */ (
        jasmine.createSpyObj('bucket', ['getFiles'])
      );
      storageServiceSpy.bucket
        .withArgs('nonExistingBucket')
        .and.returnValue(nonExistingBucket);
      nonExistingBucket.getFiles.and.rejectWith();
    });

    it('returns false when a bucket does not exist', async () => {
      expect(
        await Config.TEST_ONLY.checkBucketExists(
          'nonExistingBucket',
          'configname',
          storageServiceSpy,
        ),
      ).toBeFalse();
    });
    it('returns true when a bucket exists', async () => {
      expect(
        await Config.TEST_ONLY.checkBucketExists(
          'existingBucket',
          'configname',
          storageServiceSpy,
        ),
      ).toBeTrue();
    });
  });

  describe('validateConfig', () => {
    it('comments are removed', async () => {
      const config = structuredClone(GOOD_CONFIG);
      (config.comments = ['HELLO WORLD']),
        expect(
          await Config.TEST_ONLY.validateConfig(config, storageServiceSpy),
        ).toEqual(GOOD_CONFIG);
    });

    it('populates missing values for fileExclusionRegexps and ignoreZeroLengthFiles', async () => {
      const config = /** @type {any} */ (structuredClone(GOOD_CONFIG));
      delete config.fileExclusionPatterns;
      delete config.fileExclusionRegexps;
      delete config.ignoreZeroLengthFiles;

      await expectAsync(
        Config.TEST_ONLY.validateConfig(config, storageServiceSpy),
      ).toBeResolvedTo(GOOD_CONFIG);
    });

    it('missing buckets trigger failure', async () => {
      // non exisiting buckets calls to getFiles rejects
      const nonExistingBucket = /** @type {jasmine.SpyObj<Bucket>} */ (
        jasmine.createSpyObj('bucket', ['getFiles'])
      );
      storageServiceSpy.bucket
        .withArgs('nonExistingBucket')
        .and.returnValue(nonExistingBucket);
      nonExistingBucket.getFiles.and.rejectWith();

      const config = structuredClone(GOOD_CONFIG);

      config.ClamCvdMirrorBucket = 'nonExistingBucket';
      await expectAsync(
        Config.TEST_ONLY.validateConfig(config, storageServiceSpy),
      ).toBeRejectedWithError('Invalid configuration');

      config.ClamCvdMirrorBucket = GOOD_CONFIG.ClamCvdMirrorBucket;
      config.buckets[0].clean = 'nonExistingBucket';
      await expectAsync(
        Config.TEST_ONLY.validateConfig(config, storageServiceSpy),
      ).toBeRejectedWithError('Invalid configuration');

      config.buckets[0].clean = GOOD_CONFIG.buckets[0].clean;
      config.buckets[0].unscanned = 'nonExistingBucket';
      await expectAsync(
        Config.TEST_ONLY.validateConfig(config, storageServiceSpy),
      ).toBeRejectedWithError('Invalid configuration');

      config.buckets[0].unscanned = GOOD_CONFIG.buckets[0].unscanned;
      config.buckets[0].quarantined = 'nonExistingBucket';
      await expectAsync(
        Config.TEST_ONLY.validateConfig(config, storageServiceSpy),
      ).toBeRejectedWithError('Invalid configuration');
    });

    it('identical buckets in same group trigger failure', async () => {
      const config = structuredClone(GOOD_CONFIG);

      config.buckets[0].quarantined = GOOD_CONFIG.buckets[0].unscanned;
      await expectAsync(
        Config.TEST_ONLY.validateConfig(config, storageServiceSpy),
      ).toBeRejectedWithError('Invalid configuration');

      config.buckets[0].quarantined = GOOD_CONFIG.buckets[0].quarantined;
      config.buckets[0].clean = GOOD_CONFIG.buckets[0].unscanned;
      await expectAsync(
        Config.TEST_ONLY.validateConfig(config, storageServiceSpy),
      ).toBeRejectedWithError('Invalid configuration');

      config.buckets[0].clean = GOOD_CONFIG.buckets[0].clean;
      config.buckets[0].quarantined = GOOD_CONFIG.buckets[0].clean;
      await expectAsync(
        Config.TEST_ONLY.validateConfig(config, storageServiceSpy),
      ).toBeRejectedWithError('Invalid configuration');
    });

    it('validates ignoreZeroLengthFiles', async () => {
      let config = /** @type {any} */ (structuredClone(GOOD_CONFIG));

      config.ignoreZeroLengthFiles = null;
      let validatedConfig = await Config.TEST_ONLY.validateConfig(
        config,
        storageServiceSpy,
      );
      expect(validatedConfig.ignoreZeroLengthFiles).toEqual(false);

      config = /** @type {any} */ (structuredClone(GOOD_CONFIG));
      config.ignoreZeroLengthFiles = true;
      validatedConfig = await Config.TEST_ONLY.validateConfig(
        config,
        storageServiceSpy,
      );
      expect(validatedConfig.ignoreZeroLengthFiles).toEqual(true);

      config = /** @type {any} */ (structuredClone(GOOD_CONFIG));
      config.ignoreZeroLengthFiles = false;
      validatedConfig = await Config.TEST_ONLY.validateConfig(
        config,
        storageServiceSpy,
      );
      expect(validatedConfig.ignoreZeroLengthFiles).toEqual(false);

      config = /** @type {any} */ (structuredClone(GOOD_CONFIG));
      config.ignoreZeroLengthFiles = 123;
      await expectAsync(
        Config.TEST_ONLY.validateConfig(config, storageServiceSpy),
      ).toBeRejectedWithError('Invalid configuration');
    });

    it('validates fileExclusionPatterns, rejecting invalid ones', async () => {
      let config = /** @type {any} */ (structuredClone(GOOD_CONFIG));
      config.fileExclusionPatterns = 123;
      await expectAsync(
        Config.TEST_ONLY.validateConfig(config, storageServiceSpy),
      ).toBeRejectedWithError('Invalid configuration');

      config = /** @type {any} */ (structuredClone(GOOD_CONFIG));
      config.fileExclusionPatterns = [123];
      await expectAsync(
        Config.TEST_ONLY.validateConfig(config, storageServiceSpy),
      ).toBeRejectedWithError('Invalid configuration');

      config = /** @type {any} */ (structuredClone(GOOD_CONFIG));
      config.fileExclusionPatterns = [[123]];
      await expectAsync(
        Config.TEST_ONLY.validateConfig(config, storageServiceSpy),
      ).toBeRejectedWithError('Invalid configuration');

      config = /** @type {any} */ (structuredClone(GOOD_CONFIG));
      config.fileExclusionPatterns = ['invalid_regex ('];
      await expectAsync(
        Config.TEST_ONLY.validateConfig(config, storageServiceSpy),
      ).toBeRejectedWithError('Invalid configuration');

      config = /** @type {any} */ (structuredClone(GOOD_CONFIG));
      config.fileExclusionPatterns = [['invalid_regex_flag', '*']];
      await expectAsync(
        Config.TEST_ONLY.validateConfig(config, storageServiceSpy),
      ).toBeRejectedWithError('Invalid configuration');
    });

    it('converts fileExclusionPatterns, to regex', async () => {
      let config = /** @type {any} */ (structuredClone(GOOD_CONFIG));
      config.fileExclusionPatterns = [
        'simple.*regex',
        ['case-insensitve.regex$', 'i'],
        '^[a-z0-9]\\.tmp$',
      ];
      let validatedConfig = await Config.TEST_ONLY.validateConfig(
        config,
        storageServiceSpy,
      );
      expect(validatedConfig.fileExclusionPatterns).toBeUndefined();
      expect(validatedConfig.fileExclusionRegexps.length).toEqual(3);
      expect(validatedConfig.fileExclusionRegexps[0]).toEqual(/simple.*regex/);
      expect(validatedConfig.fileExclusionRegexps[1]).toEqual(
        /case-insensitve.regex$/i,
      );
      expect(validatedConfig.fileExclusionRegexps[2]).toEqual(
        /^[a-z0-9]\.tmp$/,
      );
    });
  });
});
