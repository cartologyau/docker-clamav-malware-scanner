/*
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as Config from '../config.js';
import * as gcs from '@google-cloud/storage';

const GOOD_CONFIG: Config.Config = {
  buckets: [
    {
      unscanned: 'unscannedBucket',
      quarantined: 'quarantinedBucket',
      clean: 'cleanBucket',
    },
  ],
  ClamCvdMirrorBucket: 'csvMirrorBucket',
  fileExclusionRegexps: [],
  ignoreZeroLengthFiles: false,
};

describe('Config', () => {
  let storageServiceSpy: jasmine.SpyObj<gcs.Storage>;
  let existingBucket: jasmine.SpyObj<gcs.Bucket>;

  beforeEach(() => {
    storageServiceSpy = jasmine.createSpyObj<gcs.Storage>('Storage', [
      'bucket',
    ]);

    existingBucket = jasmine.createSpyObj<gcs.Bucket>('existingBucket', [
      'getFiles',
    ]);
    (existingBucket.getFiles as jasmine.Spy).and.resolveTo([]);
    [
      ...Object.values(GOOD_CONFIG.buckets[0]),
      GOOD_CONFIG.ClamCvdMirrorBucket,
    ].forEach((bucket) =>
      (storageServiceSpy.bucket as jasmine.Spy)
        .withArgs(bucket)
        .and.returnValue(existingBucket),
    );
  });

  describe('readAndVerifyConfig', () => {
    it('throws when a bad config is passed', async () => {
      await expectAsync(
        Config.readAndVerifyConfig(
          'spec/support/bad-config.notjson',
          storageServiceSpy,
        ),
      ).toBeRejectedWithError(SyntaxError, /Expected property/);
    });

    it('throws when a missing config file is passed', async () => {
      await expectAsync(
        Config.readAndVerifyConfig(
          'spec/support/no-config-file.json',
          storageServiceSpy,
        ),
      ).toBeRejectedWithError(/no such file or directory/);
    });

    it('returns config when a good config file is passed', async () => {
      const config = await Config.readAndVerifyConfig(
        'spec/support/good-config.json',
        storageServiceSpy,
      );
      expect(config).toEqual(GOOD_CONFIG);
      // eslint-disable-next-line @typescript-eslint/unbound-method
      expect(existingBucket.getFiles as jasmine.Spy).toHaveBeenCalledTimes(4);
    });
  });

  describe('checkBucketExists', () => {
    beforeEach(() => {
      (storageServiceSpy.bucket as jasmine.Spy)
        .withArgs('existingBucket')
        .and.returnValue(existingBucket);

      const nonExistingBucket = jasmine.createSpyObj<gcs.Bucket>('bucket', [
        'getFiles',
      ]);
      (storageServiceSpy.bucket as jasmine.Spy)
        .withArgs('nonExistingBucket')
        .and.returnValue(nonExistingBucket);
      (nonExistingBucket.getFiles as jasmine.Spy).and.rejectWith(
        new Error('Bucket not found'),
      );
    });

    it('returns false when a bucket does not exist', async () => {
      expect(
        await Config.TEST_ONLY.checkBucketExists(
          'nonExistingBucket',
          'configname',
          storageServiceSpy,
        ),
      ).toBeFalse();
    });
    it('returns true when a bucket exists', async () => {
      expect(
        await Config.TEST_ONLY.checkBucketExists(
          'existingBucket',
          'configname',
          storageServiceSpy,
        ),
      ).toBeTrue();
    });
  });

  // Working with 'any' to validate the config validator!
  /* eslint-disable @typescript-eslint/no-unsafe-member-access */
  /* eslint-disable @typescript-eslint/no-explicit-any */
  /* eslint-disable @typescript-eslint/no-unsafe-assignment */
  describe('validateConfig', () => {
    it('comments are removed', async () => {
      const config = structuredClone(GOOD_CONFIG);

      (config as any).comments = ['HELLO WORLD'];
      expect(
        await Config.TEST_ONLY.validateConfig(config, storageServiceSpy),
      ).toEqual(GOOD_CONFIG);
    });

    it('populates missing values for fileExclusionRegexps and ignoreZeroLengthFiles', async () => {
      const config = structuredClone(GOOD_CONFIG) as any;
      delete config.fileExclusionPatterns;
      delete config.fileExclusionRegexps;
      delete config.ignoreZeroLengthFiles;

      await expectAsync(
        Config.TEST_ONLY.validateConfig(config, storageServiceSpy),
      ).toBeResolvedTo(GOOD_CONFIG);
    });

    it('missing buckets trigger failure', async () => {
      const nonExistingBucket = jasmine.createSpyObj('bucket', ['getFiles']);
      (storageServiceSpy.bucket as jasmine.Spy)
        .withArgs('nonExistingBucket')
        .and.returnValue(nonExistingBucket);
      (nonExistingBucket.getFiles as jasmine.Spy).and.rejectWith(
        new Error('Bucket not found'),
      );

      const config = structuredClone(GOOD_CONFIG);

      config.ClamCvdMirrorBucket = 'nonExistingBucket';
      await expectAsync(
        Config.TEST_ONLY.validateConfig(config, storageServiceSpy),
      ).toBeRejectedWithError('Invalid configuration');

      config.ClamCvdMirrorBucket = GOOD_CONFIG.ClamCvdMirrorBucket;
      config.buckets[0].clean = 'nonExistingBucket';
      await expectAsync(
        Config.TEST_ONLY.validateConfig(config, storageServiceSpy),
      ).toBeRejectedWithError('Invalid configuration');

      config.buckets[0].clean = GOOD_CONFIG.buckets[0].clean;
      config.buckets[0].unscanned = 'nonExistingBucket';
      await expectAsync(
        Config.TEST_ONLY.validateConfig(config, storageServiceSpy),
      ).toBeRejectedWithError('Invalid configuration');

      config.buckets[0].unscanned = GOOD_CONFIG.buckets[0].unscanned;
      config.buckets[0].quarantined = 'nonExistingBucket';
      await expectAsync(
        Config.TEST_ONLY.validateConfig(config, storageServiceSpy),
      ).toBeRejectedWithError('Invalid configuration');
    });

    it('identical buckets in same group trigger failure', async () => {
      const config = structuredClone(GOOD_CONFIG);

      config.buckets[0].quarantined = GOOD_CONFIG.buckets[0].unscanned;
      await expectAsync(
        Config.TEST_ONLY.validateConfig(config, storageServiceSpy),
      ).toBeRejectedWithError('Invalid configuration');

      config.buckets[0].quarantined = GOOD_CONFIG.buckets[0].quarantined;
      config.buckets[0].clean = GOOD_CONFIG.buckets[0].unscanned;
      await expectAsync(
        Config.TEST_ONLY.validateConfig(config, storageServiceSpy),
      ).toBeRejectedWithError('Invalid configuration');

      config.buckets[0].clean = GOOD_CONFIG.buckets[0].clean;
      config.buckets[0].quarantined = GOOD_CONFIG.buckets[0].clean;
      await expectAsync(
        Config.TEST_ONLY.validateConfig(config, storageServiceSpy),
      ).toBeRejectedWithError('Invalid configuration');
    });

    it('validates ignoreZeroLengthFiles', async () => {
      let config = structuredClone(GOOD_CONFIG) as any;

      config.ignoreZeroLengthFiles = null;
      let validatedConfig = await Config.TEST_ONLY.validateConfig(
        config,
        storageServiceSpy,
      );
      expect(validatedConfig.ignoreZeroLengthFiles).toEqual(false);

      config = structuredClone(GOOD_CONFIG) as any;
      config.ignoreZeroLengthFiles = true;
      validatedConfig = await Config.TEST_ONLY.validateConfig(
        config,
        storageServiceSpy,
      );
      expect(validatedConfig.ignoreZeroLengthFiles).toEqual(true);

      config = structuredClone(GOOD_CONFIG) as any;
      config.ignoreZeroLengthFiles = false;
      validatedConfig = await Config.TEST_ONLY.validateConfig(
        config,
        storageServiceSpy,
      );
      expect(validatedConfig.ignoreZeroLengthFiles).toEqual(false);

      config = structuredClone(GOOD_CONFIG) as any;
      config.ignoreZeroLengthFiles = 123;
      await expectAsync(
        Config.TEST_ONLY.validateConfig(config, storageServiceSpy),
      ).toBeRejectedWithError('Invalid configuration');
    });

    it('validates fileExclusionPatterns, rejecting invalid ones', async () => {
      let config = structuredClone(GOOD_CONFIG) as any;
      config.fileExclusionPatterns = 123;
      await expectAsync(
        Config.TEST_ONLY.validateConfig(config, storageServiceSpy),
      ).toBeRejectedWithError('Invalid configuration');

      config = structuredClone(GOOD_CONFIG) as any;
      config.fileExclusionPatterns = [123];
      await expectAsync(
        Config.TEST_ONLY.validateConfig(config, storageServiceSpy),
      ).toBeRejectedWithError('Invalid configuration');

      config = structuredClone(GOOD_CONFIG) as any;
      config.fileExclusionPatterns = [[123]];
      await expectAsync(
        Config.TEST_ONLY.validateConfig(config, storageServiceSpy),
      ).toBeRejectedWithError('Invalid configuration');

      config = structuredClone(GOOD_CONFIG) as any;
      config.fileExclusionPatterns = ['invalid_regex ('];
      await expectAsync(
        Config.TEST_ONLY.validateConfig(config, storageServiceSpy),
      ).toBeRejectedWithError('Invalid configuration');

      config = structuredClone(GOOD_CONFIG) as any;
      config.fileExclusionPatterns = [['invalid_regex_flag', '*']];
      await expectAsync(
        Config.TEST_ONLY.validateConfig(config, storageServiceSpy),
      ).toBeRejectedWithError('Invalid configuration');
    });

    it('converts fileExclusionPatterns, to regex', async () => {
      const config = structuredClone(GOOD_CONFIG) as any;
      config.fileExclusionPatterns = [
        'simple.*regex',
        ['case-insensitve.regex$', 'i'],
        '^[a-z0-9]\\.tmp$',
      ];
      const validatedConfig = await Config.TEST_ONLY.validateConfig(
        config,
        storageServiceSpy,
      );
      expect(validatedConfig.fileExclusionPatterns).toBeUndefined();
      expect(validatedConfig.fileExclusionRegexps.length).toEqual(3);
      expect(validatedConfig.fileExclusionRegexps[0]).toEqual(/simple.*regex/);
      expect(validatedConfig.fileExclusionRegexps[1]).toEqual(
        /case-insensitve.regex$/i,
      );
      expect(validatedConfig.fileExclusionRegexps[2]).toEqual(
        /^[a-z0-9]\.tmp$/,
      );
    });
  });
});
