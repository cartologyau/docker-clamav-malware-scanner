const {Scanner} = require('../scanner.js');
const metrics = require('../metrics');

/**
 * @typedef {import('../config.js').Config} Config
 * @typedef {import('../config.js').BucketDefs} BucketDefs
 * @typedef {import('node:stream').Readable} Readable
 * @typedef {typeof import('../metrics.js')} MetricsClient
 * @typedef {import('@google-cloud/storage').Storage} Storage
 * @typedef {import('@google-cloud/storage').Bucket} Bucket
 * @typedef {import('@google-cloud/storage').File} File
 * @typedef {import('@google-cloud/storage').FileExistsResponse} FileExistsResponse
 * @typedef {import('../scanner').ScanStreamFunc} ScanStreamFunc
 */

// @ts-ignore -- TS7016: Could not find a declaration file
/** @typedef {typeof import('clamdjs')} ClamdClient */

/** @type {Config} */
const CONFIG = {
  buckets: [
    {
      unscanned: 'unscannedBucket',
      quarantined: 'quarantinedBucket',
      clean: 'cleanBucket',
    },
  ],
  ClamCvdMirrorBucket: 'csvMirrorBucket',
  fileExclusionRegexps: [],
  ignoreZeroLengthFiles: false,
};

const CLAMD_VERSION_STRING = 'clamd_version_string';
const TEST_FILE_NAME = 'testFileName';

describe('Scanner', () => {
  /** @type {jasmine.SpyObj<ClamdClient>} */
  let clamdClient;
  /** @type {jasmine.Spy<ScanStreamFunc>} */
  let scanStreamFunc;
  /** @type {jasmine.SpyObj<MetricsClient>} */
  let metricsClient;
  /** @type {jasmine.SpyObj<Storage>} */
  let storageClient;
  /** @type {jasmine.SpyObj<Bucket>} */
  let mockUnscannedBucket;
  /** @type {jasmine.SpyObj<Bucket>} */
  let mockCleanBucket;
  /** @type {jasmine.SpyObj<Bucket>} */
  let mockQuarantinedBucket;
  /** @type {jasmine.SpyObj<File>} */
  let mockFile;

  /** @type {Scanner} */
  let scanner;

  beforeEach(() => {
    clamdClient = jasmine.createSpyObj('ClamdClient', [
      'createScanner',
      'version',
      'ping',
      'isCleanReply',
    ]);
    scanStreamFunc = jasmine.createSpy('scanStreamFunc');
    clamdClient.createScanner.and.returnValue({scanStream: scanStreamFunc});
    // @ts-ignore -- clamdjs.version signature incorrect - should return a promise
    clamdClient.version.and.resolveTo('clamd_version_string\x00');

    // create mock Metrics
    metricsClient = jasmine.createSpyObj('MetricsClient', Object.keys(metrics));

    storageClient = jasmine.createSpyObj('Storage', ['bucket']);

    mockUnscannedBucket = jasmine.createSpyObj('unscannedBucket', ['file']);
    storageClient.bucket
      .withArgs('unscannedBucket')
      .and.returnValue(mockUnscannedBucket);

    mockCleanBucket = jasmine.createSpyObj('cleanBucket', ['file']);
    storageClient.bucket
      .withArgs('cleanBucket')
      .and.returnValue(mockCleanBucket);

    mockQuarantinedBucket = jasmine.createSpyObj('quarantinedBucket', ['file']);
    storageClient.bucket
      .withArgs('quarantinedBucket')
      .and.returnValue(mockQuarantinedBucket);

    mockFile = jasmine.createSpyObj(
      'testFile',
      ['exists', 'getMetadata', 'createReadStream', 'move'],
      {name: TEST_FILE_NAME},
    );
    mockUnscannedBucket.file.withArgs(TEST_FILE_NAME).and.returnValue(mockFile);

    scanner = new Scanner(CONFIG, clamdClient, storageClient, metricsClient);
  });

  it('version returns the version', async () => {
    await expectAsync(scanner.getClamVersion()).toBeResolvedTo(
      CLAMD_VERSION_STRING,
    );
  });

  it('successful pings return', async () => {
    // @ts-ignore -- clamdjs.version signature incorrect - should return a promise
    clamdClient.ping.and.resolveTo(true);
    await expectAsync(scanner.pingClamD()).toBeResolved();
  });
  it('unsuccessful pings throw', async () => {
    // @ts-ignore -- clamdjs.version signature incorrect - should return a promise
    clamdClient.ping.and.resolveTo(false);
    await expectAsync(scanner.pingClamD()).toBeRejectedWithError(
      /clamd PING failed/,
    );

    // @ts-ignore -- clamdjs.version signature incorrect - should return a promise
    clamdClient.ping.and.throwError('exception in Ping');
    await expectAsync(scanner.pingClamD()).toBeRejectedWithError(
      /exception in Ping/,
    );
  });

  describe('handleGcsObject', () => {
    it('validates input', async () => {
      const response = {message: 'ignoring invalid request', status: 'ignored'};

      /** @type {import('../scanner.js').StorageObjectData} */
      // @ts-ignore -- cannot be assigned
      let request = null;
      await expectAsync(scanner.handleGcsObject(request)).toBeResolvedTo(
        response,
      );
      // @ts-ignore -- cannot be assigned
      request = {};
      await expectAsync(scanner.handleGcsObject(request)).toBeResolvedTo(
        response,
      );
      request.name = 'filename';
      await expectAsync(scanner.handleGcsObject(request)).toBeResolvedTo(
        response,
      );
      request.bucket = 'size';
      await expectAsync(scanner.handleGcsObject(request)).toBeResolvedTo(
        response,
      );
      request.bucket = 'invalid_bucket';
      await expectAsync(scanner.handleGcsObject(request)).toBeResolvedTo(
        response,
      );
      expect(metricsClient.writeScanFailed).toHaveBeenCalledTimes(5);
    });

    it('ignores zero length files when set', async () => {
      const config = structuredClone(CONFIG);
      config.ignoreZeroLengthFiles = true;

      scanner = new Scanner(config, clamdClient, storageClient, metricsClient);

      const request = {name: 'filename', bucket: 'unscannedBucket', size: 0};
      await expectAsync(scanner.handleGcsObject(request)).toBeResolvedTo({
        status: 'ignored',
        message: 'zero_length_file',
      });
      expect(metricsClient.writeScanIgnored).toHaveBeenCalledWith(
        CONFIG.buckets[0].unscanned,
        CONFIG.buckets[0].clean,
        0,
        'ZERO_LENGTH_FILE',
      );
    });

    it('ignores files that are too large', async () => {
      const request = {
        name: 'filename',
        bucket: 'unscannedBucket',
        size: 501000000,
      };
      await expectAsync(scanner.handleGcsObject(request)).toBeResolvedTo({
        status: 'ignored',
        message: 'file_too_large',
      });
      expect(metricsClient.writeScanIgnored).toHaveBeenCalledWith(
        CONFIG.buckets[0].unscanned,
        CONFIG.buckets[0].clean,
        request.size,
        'FILE_TOO_LARGE',
      );
    });

    it('ignores files that match exclusion regex', async () => {
      const config = structuredClone(CONFIG);
      config.fileExclusionRegexps = [/\.tmp$/, /\.multipart\./i];

      scanner = new Scanner(config, clamdClient, storageClient, metricsClient);

      const request = {name: 'file.tmp', bucket: 'unscannedBucket', size: 100};
      await expectAsync(scanner.handleGcsObject(request)).toBeResolvedTo({
        status: 'ignored',
        message: 'exclusion_regexp_match',
      });

      request.name = 'file.multIPART.txt';
      await expectAsync(scanner.handleGcsObject(request)).toBeResolvedTo({
        status: 'ignored',
        message: 'exclusion_regexp_match',
      });

      expect(metricsClient.writeScanIgnored).toHaveBeenCalledWith(
        CONFIG.buckets[0].unscanned,
        CONFIG.buckets[0].clean,
        100,
        'REGEXP_MATCH',
        '/\\.tmp$/',
      );
      expect(metricsClient.writeScanIgnored).toHaveBeenCalledWith(
        CONFIG.buckets[0].unscanned,
        CONFIG.buckets[0].clean,
        100,
        'REGEXP_MATCH',
        '/\\.multipart\\./i',
      );
    });

    it('ignores files who get removed before processing', async () => {
      // @ts-ignore -- for some reason, the overloading is not recognised.
      mockFile.exists.and.resolveTo([false]);

      const request = {
        name: TEST_FILE_NAME,
        bucket: 'unscannedBucket',
        size: 100,
      };
      await scanner.handleGcsObject(request);
      await expectAsync(scanner.handleGcsObject(request)).toBeResolvedTo({
        status: 'ignored',
        message: 'file deleted',
      });
      expect(metricsClient.writeScanIgnored).not.toHaveBeenCalled();
      expect(metricsClient.writeScanClean).not.toHaveBeenCalled();
      expect(metricsClient.writeScanFailed).not.toHaveBeenCalled();
    });

    it('ignores files whos size changes before processing', async () => {
      // @ts-ignore -- for some reason, the overloading is not recognised.
      mockFile.exists.and.resolveTo([true]);
      // @ts-ignore -- for some reason, the overloading is not recognised.
      mockFile.getMetadata.and.resolveTo([{size: 200}]);

      const request = {
        name: TEST_FILE_NAME,
        bucket: 'unscannedBucket',
        size: 100,
      };
      await scanner.handleGcsObject(request);
      await expectAsync(scanner.handleGcsObject(request)).toBeResolvedTo({
        status: 'ignored',
        message: 'file_size_mismatch',
      });
      expect(metricsClient.writeScanIgnored).toHaveBeenCalledWith(
        CONFIG.buckets[0].unscanned,
        CONFIG.buckets[0].clean,
        100,
        'FILE_SIZE_MISMATCH',
      );
      expect(metricsClient.writeScanClean).not.toHaveBeenCalled();
      expect(metricsClient.writeScanFailed).not.toHaveBeenCalled();
    });

    describe('scans files', () => {
      const request = {
        name: TEST_FILE_NAME,
        bucket: 'unscannedBucket',
        size: 100,
      };
      /** @type {jasmine.SpyObj<Readable>} */
      let mockReadStream;

      beforeEach(() => {
        // @ts-ignore -- for some reason, the overloading is not recognised.
        mockFile.exists.and.resolveTo([true]);
        // @ts-ignore -- for some reason, the overloading is not recognised.
        mockFile.getMetadata.and.resolveTo([{size: 100}]);

        mockReadStream = jasmine.createSpyObj('readableStream', ['destroy']);
        // @ts-ignore -- for some reason, the overloading is not recognised.
        mockFile.createReadStream.and.resolveTo(mockReadStream);

        jasmine.clock().install();
        jasmine.clock().mockDate(new Date('2024-01-01T01:00:00Z'));
      });
      afterEach(() => {
        jasmine.clock().uninstall();
      });

      it('throws when getting the stream fails', async () => {
        // @ts-ignore -- for some reason, the overloading is not recognised.
        mockFile.createReadStream.and.rejectWith('createReadStream Fail');

        await expectAsync(scanner.handleGcsObject(request)).toBeRejectedWith(
          'createReadStream Fail',
        );

        expect(metricsClient.writeScanFailed).toHaveBeenCalledWith(
          CONFIG.buckets[0].unscanned,
        );
      });

      it('throws when scanning the file fails', async () => {
        scanStreamFunc.and.rejectWith('scanfile fail');
        await expectAsync(scanner.handleGcsObject(request)).toBeRejectedWith(
          'scanfile fail',
        );
        expect(metricsClient.writeScanFailed).toHaveBeenCalledWith(
          CONFIG.buckets[0].unscanned,
        );
        expect(mockReadStream.destroy).toHaveBeenCalled();
      });

      it('moves clean files and logs metrics', async () => {
        scanStreamFunc.and.resolveTo('scan success');
        clamdClient.isCleanReply.and.returnValue(true);
        mockFile.move.and.resolveTo();

        await expectAsync(scanner.handleGcsObject(request)).toBeResolvedTo({
          status: 'clean',
          clam_version: CLAMD_VERSION_STRING,
          message: 'scan_success',
        });

        expect(mockReadStream.destroy).toHaveBeenCalled();
        // @ts-ignore - overloading failing to match.
        expect(mockFile.move).toHaveBeenCalledWith(mockCleanBucket);
        expect(metricsClient.writeScanClean).toHaveBeenCalledWith(
          CONFIG.buckets[0].unscanned,
          CONFIG.buckets[0].clean,
          100,
          0,
          CLAMD_VERSION_STRING,
        );
      });

      it('moves infected files and logs metrics', async () => {
        scanStreamFunc.and.resolveTo('scan infected');
        clamdClient.isCleanReply.and.returnValue(false);
        mockFile.move.and.resolveTo();

        await expectAsync(scanner.handleGcsObject(request)).toBeResolvedTo({
          message: 'scan infected',
          status: 'infected',
          clam_version: CLAMD_VERSION_STRING,
        });

        expect(mockReadStream.destroy).toHaveBeenCalled();
        // @ts-ignore - overloading failing to match.
        expect(mockFile.move).toHaveBeenCalledWith(mockQuarantinedBucket);
        expect(metricsClient.writeScanInfected).toHaveBeenCalledWith(
          CONFIG.buckets[0].unscanned,
          CONFIG.buckets[0].quarantined,
          100,
          0,
          CLAMD_VERSION_STRING,
        );
      });
    });
  });
});
