/*
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {logger} from './logger';
import {readFileSync} from 'node:fs';
import {Storage} from '@google-cloud/storage';

/**
 * Configuration object.
 *
 * Values are read from the JSON configuration file.
 * See {@link readAndVerifyConfig}.
 */
export type BucketDefs = {
  unscanned: string;
  clean: string;
  quarantined: string;
};

export type Config = {
  buckets: Array<BucketDefs>;
  ClamCvdMirrorBucket: string;
  fileExclusionPatterns?: Array<string | Array<string>>;
  fileExclusionRegexps: Array<RegExp>;
  ignoreZeroLengthFiles: boolean;
  comments?: string | string[];
};

const BUCKET_TYPES = ['unscanned', 'clean', 'quarantined'] as Array<
  keyof BucketDefs
>;

/**
 * Read configuration from JSON configuration file, parse, verify
 * and return a Config object
 *
 * @async
 * @param {string} configFile
 * @param {Storage} storage
 * @return {Promise<Config>}
 */
export async function readAndVerifyConfig(
  configFile: string,
  storage: Storage,
): Promise<Config> {
  logger.info(`Using configuration file: ${configFile}`);
  let configText;
  try {
    configText = readFileSync(configFile, {encoding: 'utf-8'});
  } catch (e: any) {
    logger.fatal(
      e,
      `Unable to read JSON file from ${configFile}: ${e.message}`,
    );
    throw e;
  }
  try {
    return validateConfig(parseConfig(configText), storage);
  } catch (e: any) {
    logger.fatal(e, `Failed parsing config file: ${configFile}: ${e.message}`);
    throw e;
  }
}

/**
 * @param {string} configText
 * @returns {Config}
 */
function parseConfig(configText: string): Config {
  /** @type {Config} */
  let config;

  try {
    config = JSON.parse(configText);
  } catch (e: any) {
    throw new Error(`Failed to parse configuration as JSON: ${e}`);
  }
  return config;
}

/**
 * Read configuration from JSON configuration file, verify
 * and return a Config object
 *
 * @async
 * @param {any} config
 * @param {Storage} storage
 * @return {Promise<Config>}
 */
async function validateConfig(config: any, storage: Storage): Promise<Config> {
  delete config.comments;

  if (config.buckets.length === 0) {
    logger.fatal(`No buckets configured for scanning`);
    throw new Error('No buckets configured');
  }

  logger.info('BUCKET_CONFIG: ' + JSON.stringify(config, null, 2));

  // Check buckets are specified and exist.
  let success = true;
  for (let x = 0; x < config.buckets.length; x++) {
    const bucketDefs = config.buckets[x];
    for (const bucketType of BUCKET_TYPES) {
      if (
        !(await checkBucketExists(
          bucketDefs[bucketType],
          `config.buckets[${x}].${bucketType}`,
          storage,
        ))
      ) {
        success = false;
      }
    }
    if (
      bucketDefs.unscanned === bucketDefs.clean ||
      bucketDefs.unscanned === bucketDefs.quarantined ||
      bucketDefs.clean === bucketDefs.quarantined
    ) {
      logger.fatal(`Config Error: buckets[${x}]: bucket names are not unique`);
      success = false;
    }
  }
  if (
    !(await checkBucketExists(
      config.ClamCvdMirrorBucket,
      'ClamCvdMirrorBucket',
      storage,
    ))
  ) {
    success = false;
  }

  // Validate ignoreZeroLengthFiles
  if (config.ignoreZeroLengthFiles == null) {
    config.ignoreZeroLengthFiles = false;
  } else if (typeof config.ignoreZeroLengthFiles !== 'boolean') {
    logger.fatal(
      `Config Error: ignoreZeroLengthFiles must be true or false: ${JSON.stringify(config.ignoreZeroLengthFiles)}`,
    );
    success = false;
  }

  // Validate fileExclusionPatterns[] and convert to fileExclusionRegexps[]
  config.fileExclusionRegexps = [];
  if (config.fileExclusionPatterns != null) {
    if (!(config.fileExclusionPatterns instanceof Array)) {
      logger.fatal(
        `Config Error: fileExclusionPatterns must be an array of Strings`,
      );
      success = false;
    } else {
      // config.fileExclusionPatterns is an array, check each value and
      // convert to a regexp in fileExclusionRegexps[]
      for (const i in config.fileExclusionPatterns) {
        let pattern: string | undefined;
        let flags: string | undefined;

        // Each element can either be a simple pattern:
        //   "^.*\\.tmp$"
        // or an array with pattern and flags, eg for case-insensive matching:
        //   [ "^.*\\tmp$", "i" ]
        const element = config.fileExclusionPatterns[i];
        if (typeof element === 'string') {
          // validate regex as simple string
          pattern = element;
        } else if (
          Array.isArray(element) &&
          element.length <= 2 &&
          element.length >= 1 &&
          typeof element[0] === 'string'
        ) {
          // validate regex as [pattern, flags]
          pattern = element[0];
          flags = element[1];
        } else {
          pattern = undefined;
        }

        if (pattern == null) {
          logger.fatal(
            `Config Error: fileExclusionPatterns[${i}] must be either a string or an array of 2 strings: ${JSON.stringify(config.fileExclusionPatterns[i])}`,
          );
          success = false;
        } else {
          try {
            config.fileExclusionRegexps[i] = new RegExp(pattern, flags);
          } catch (e: any) {
            logger.fatal(
              e,
              `Config Error: fileExclusionPatterns[${i}]:  Regexp compile failed for ${JSON.stringify(config.fileExclusionPatterns[i])}: ${e.message}`,
            );
            success = false;
          }
        }
      }
    }
  }
  delete config.fileExclusionPatterns;

  if (!success) {
    throw new Error('Invalid configuration');
  }

  return Object.freeze(config);
}

/**
 * Check that given bucket exists. Returns true on success
 *
 * @param {string} bucketName
 * @param {string} configName
 * @param {Storage} storage
 * @return {Promise<boolean>}
 */
async function checkBucketExists(
  bucketName: string,
  configName: string,
  storage: Storage,
): Promise<boolean> {
  if (!bucketName) {
    logger.fatal(`Config Error: no "${configName}" bucket defined`);
    return false;
  }
  // Check for bucket existence by listing files in bucket, will throw
  // an exception if the bucket is not readable.
  // This is used in place of Bucket.exists() to avoid the need for
  // Project/viewer permission.
  try {
    await storage
      .bucket(bucketName)
      .getFiles({maxResults: 1, prefix: 'zzz', autoPaginate: false});
    return true;
  } catch (e: any) {
    logger.fatal(
      `Error in config: cannot view files in "${configName}" : ${bucketName} : ${e}`,
    );
    logger.debug({err: e});
    return false;
  }
}

export const TEST_ONLY = {
  checkBucketExists,
  validateConfig,
};
